# 订单模型


##单向订单模型
与许多中心化交易所的订单数据模型不同，路印采用的是单向订单模型（Uni-Directional Order Model，UDOM）。也就是说，无论买单还是卖单，都用一种数据结构表示 - 目前路印不支持市价单。我们先通过一个简化的模型举几个例子。

假设我们在LRC-ETH交易对，那么用0.03价格卖出500个LRC的**卖单**这样表示：
```JSON
{   // LRC-ETH市场：0.03价格卖出500个LRC的卖单
    "tokenS": "LRC",
    "tokenB": "ETH",
    "amountS": 500,
    "amountB": 15 // = 500 * 0.03
}
```
用0.03价格买入出500个LRC的**买单**这样表示：
```JSON
{   // LRC-ETH市场：0.03价格买入500个LRC的买单
    "tokenS": "ETH",
    "tokenB": "LRC",
    "amountS": 15, // = 500 * 0.03
    "amountB": 500 
}
```

> 其中的字母S代表Sell，B代表Buy。

单向订单模型中不显性表达交易对和价格。

不过这种表达有个问题：对*完全成交*的判断没有做说明。或者说，一个订单完全成交，是按照`amountS`的实际交易额达到了指定的值做标准，还是按照`amountB`的实际交易额达到了指定的值做标准。因此我们引入了另一个参数`buy`来做说明 - 如果`buy==true`，就按照`amountB`的实际交易判断是否完全成交；否者按照`amountS`的实际交易额判断。因此这上面的卖单和买单就需要这样描述：

```JSON
{   // LRC-ETH市场：0.03价格卖出500个LRC的卖单
    "tokenS": "LRC",
    "tokenB": "ETH",
    "amountS": 500,
    "amountB": 15 // = 500 * 0.03，
    "buy":     false  // 完全成交用amountS实际交易额判断
}
```

```JSON
{   // LRC-ETH市场：0.03价格买入500个LRC的买单
    "tokenS": "ETH",
    "tokenB": "LRC",
    "amountS": 15, // = 500 * 0.03
    "amountB": 500,
    "buy":     true // 完全成交用amountB实际交易额判断
}
```
注意：上面的卖单如果完全成交，实际上获得的ETH可能大于15ETH；而上面的买单如果完全成交，实际上支付的ETH可能少于15ETH。这就是`buy`这个参数决定的。

将上面两个订单的`buy`值反转，会有什么效果呢？答案很简单：LRC-ETH交易对的卖单就变成了ETH-LRC交易对的买单；而LRC-ETH交易对的买单就变成了ETH-LRC交易对的卖单。也就是说，路印协议的一个交易对，实际上等同于LRC-ETH和ETH-LRC两个交易对，并且可以表达这个两个交易对各自的买卖单，并将其一起撮合。

- **TODO**: 马超，实际撮合引擎是否允许上面的4种组合？

## 订单数据
路印实际的订单格式要更加复杂一些。您可以通过下面的JSON来表达一个路印的限价单。具体参数细节详见[提交订单](../dex_apis/submitOrder.md)。

```python
newOrder = {
    "tokenSId": 2,  // LRC
    "tokenBId": 0,  // ETH
    "amountS": "500000000000000000000",
    "amountB": "15000000000000000000",
    "buy": "false",
    "exchangeId": 2,
    "accountId": 1234,
    "allOrNone": "false",
    "maxFeeBips": 50,
    "label": 211,
    "validSince": 1582094327,
    "validUntil": 1587278341,
    "orderId": 5,
    "hash": "14504358714580556901944011952143357684927684879578923674101657902115012783290",
    "signatureRx": "15179969700843231746888635151106024191752286977677731880613780154804077177446",
    "signatureRy": "8103765835373541952843207933665617916816772340145691265012430975846006955894",
    "signatureS" : "4462707474665244243174020779004308974607763640730341744048308145656189589982",
    "clientOrderId": "Test01"
}
```

接下来我们对其中的某些数据项做进一步说明。

#### 通证和数量
与简化模型不同，实际订单中通证不用字符串或者其ERC20地址表达，而是使用该通证在路印交易所的合约中注册的序号（Token ID）表达。上面的例子中，我们假设LRC和ETH的ID分别是2和0。

交易的数量使用通证的最小单元，通过字符串类型表达。以LRC为例，LRC的ERC20合约中decimals为18，因此1个LRC应该表示为`"1000000000000000000"`(1后面跟18个0)。每个通证的decimals不同。

实际通证配置信息可以通过[交易所支持的通证信息](../dex_apis/getTokens.md)查询。

请注意：实际数据模型中`buy`的值是字符串而不是布尔型。

- **TODO**: 马超，buy、allOrNone改为bool是不是更好些？


#### 交易手续费
`maxFeeBips=50`代表该笔订单愿意支付给交易所的**最高手续费比例**是0.5%（`maxFeeBips`的单位是0.01%）。路印的交易手续费都是用成交获得的tokenB支付的。假设上面订单某次成交买入了`"10000000000000000000"`ETH（10ETH)，那么实际支付的手续费**不会超过0.05ETH**（="10000000000000000000" * 0.5%）。

实际支付的手续费比例是有路印中继决定的。中继会根据不同的VIP等级，给不同的用户相应的交易手续费折扣。路印协议不允许实际手续费比例大于用户订单中指定的最高手续费比例。

- **TODO**: 马超，交易手续费哪个API查询？

#### 生效和过期时间

`validSince`代表订单生效时间，`validUntil`代表订单过期时间，其单位均为秒。

中继服务器收到订单时会验证订单中的这两个时间戳；路印协议的零知识证明电路代码在清算时候也需要判断这两个时间戳。由于zkRollup批处理的设计，以及以太坊上时间与服务器时间可能存在偏差，我们强烈建议`validSince`设置得比当前时间至少早15分钟，即：

```python
order["validSince"] = int(time.time() + 15 * 60)
```

我们同样建议`validSince`和`validUntil`之间的时间窗口不小于1小时，否则您的订单可能不会被撮合。

{% hint style='tip' %}
请可以通过使用`validUntil`时间戳来让订单自动过期，而无需主动取消订单。
{% endhint %}


#### 订单号和交易历史


