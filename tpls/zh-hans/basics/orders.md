# 订单模型


##单向订单模型
与许多中心化交易所的订单数据模型不同，路印采用的是单向订单模型（Uni-Directional Order Model，UDOM）。也就是说，无论买单还是卖单，都用一种数据结构表示 - 目前路印不支持市价单。我们先通过一个简化的模型举几个例子。

假设我们在LRC-ETH交易对，那么用0.03价格卖出500个LRC的**卖单**这样表示：
```JSON
{   // LRC-ETH市场：0.03价格卖出500个LRC的卖单
    "tokenS": "LRC",
    "tokenB": "ETH",
    "amountS": 500,
    "amountB": 15 // = 500 * 0.03
}
```
用0.03价格买入出500个LRC的**买单**这样表示：
```JSON
{   // LRC-ETH市场：0.03价格买入500个LRC的买单
    "tokenS": "ETH",
    "tokenB": "LRC",
    "amountS": 15, // = 500 * 0.03
    "amountB": 500 
}
```

{% hint style='info' %}
订单数据项中的的字母S代表Sell，B代表Buy。
{% endhint %}

单向订单模型中不显性表达交易对和价格。

不过这种表达有个问题：对*完全成交*的判断没有做说明。或者说，一个订单完全成交，是按照`amountS`的实际交易额达到了指定的值做标准，还是按照`amountB`的实际交易额达到了指定的值做标准。因此我们引入了另一个参数`buy`来做说明 - 如果`buy==true`，就按照`amountB`的实际交易判断是否完全成交；否者按照`amountS`的实际交易额判断。因此这上面的卖单和买单就需要这样描述：

```JSON
{   // LRC-ETH市场：0.03价格卖出500个LRC的卖单
    "tokenS": "LRC",
    "tokenB": "ETH",
    "amountS": 500,
    "amountB": 15 // = 500 * 0.03，
    "buy":     false  // 完全成交用amountS实际交易额判断
}
```

```JSON
{   // LRC-ETH市场：0.03价格买入500个LRC的买单
    "tokenS": "ETH",
    "tokenB": "LRC",
    "amountS": 15, // = 500 * 0.03
    "amountB": 500,
    "buy":     true // 完全成交用amountB实际交易额判断
}
```
注意：上面的卖单如果完全成交，实际上获得的ETH可能大于15ETH；而上面的买单如果完全成交，实际上支付的ETH可能少于15ETH。这就是`buy`这个参数决定的。

将上面两个订单的`buy`值反转，会有什么效果呢？答案很简单：LRC-ETH交易对的卖单就变成了ETH-LRC交易对的买单；而LRC-ETH交易对的买单就变成了ETH-LRC交易对的卖单。也就是说，路印协议的一个交易对，实际上等同于LRC-ETH和ETH-LRC两个交易对，并且可以表达这个两个交易对各自的买卖单，并将其一起撮合。

- **TODO（马超）**: 实际撮合引擎是否允许上面的4种组合？

## 订单数据
路印实际的订单格式要更加复杂一些。您可以通过下面的JSON来表达一个路印的限价单。具体参数细节详见[提交订单](../dex_apis/submitOrder.md)。

```python
newOrder = {
    "tokenSId": 2,  // LRC
    "tokenBId": 0,  // ETH
    "amountS": "500000000000000000000",
    "amountB": "15000000000000000000",
    "buy": "false",
    "exchangeId": 2,
    "accountId": 1234,
    "allOrNone": "false",
    "maxFeeBips": 50,
    "label": 211,
    "validSince": 1582094327,
    "validUntil": 1587278341,
    "orderId": 5,
    "hash": "14504358714580556901944011952143357684927684879578923674101657902115012783290",
    "signatureRx": "15179969700843231746888635151106024191752286977677731880613780154804077177446",
    "signatureRy": "8103765835373541952843207933665617916816772340145691265012430975846006955894",
    "signatureS" : "4462707474665244243174020779004308974607763640730341744048308145656189589982",
    "clientOrderId": "Test01"
}
```

接下来我们对其中的某些数据项做进一步说明。

#### 通证和数量
与简化模型不同，实际订单中通证不用字符串或者其ERC20地址表达，而是使用该通证在路印交易所的合约中注册的序号（Token ID）表达。上面的例子中，我们假设LRC和ETH的ID分别是2和0。

交易的数量使用通证的最小单元，通过字符串类型表达。以LRC为例，LRC的ERC20合约中decimals为18，因此1个LRC应该表示为`"1000000000000000000"`(1后面跟18个0)。每个通证的decimals不同。

实际通证配置信息可以通过[交易所支持的通证信息](../dex_apis/getTokens.md)查询。

请注意：实际数据模型中`buy`的值是字符串而不是布尔型。

- **TODO（马超）**: buy、allOrNone改为bool是不是更好些？


#### 交易手续费
`maxFeeBips=50`代表该笔订单愿意支付给交易所的**最高手续费比例**是0.5%（`maxFeeBips`的单位是0.01%）。路印的交易手续费都是用成交获得的tokenB支付的。假设上面订单某次成交买入了`"10000000000000000000"`ETH（10ETH)，那么实际支付的手续费**不会超过0.05ETH**（="10000000000000000000" * 0.5%）。

实际支付的手续费比例是有路印中继决定的。中继会根据不同的VIP等级，给不同的用户相应的交易手续费折扣。路印协议不允许实际手续费比例大于用户订单中指定的最高手续费比例。

- **TODO**: 马超，交易手续费哪个API查询？

#### 生效和过期时间

`validSince`代表订单生效时间，`validUntil`代表订单过期时间，其单位均为秒。

中继服务器收到订单时会验证订单中的这两个时间戳；路印协议的零知识证明电路代码在清算时候也需要判断这两个时间戳。由于zkRollup批处理的设计，以及以太坊上时间与服务器时间可能存在偏差，我们强烈建议`validSince`设置得比当前时间至少早15分钟，即：

```python
order["validSince"] = int(time.time() + 15 * 60)
```

我们同样建议`validSince`和`validUntil`之间的时间窗口不小于1小时，否则您的订单可能不会被撮合。

{% hint style='tip' %}
请可以通过使用`validUntil`时间戳来让订单自动过期，而无需主动取消订单。
{% endhint %}


#### 订单状态与订单号


路印协议3.1.1为支持的每个通证预留了16384（$$2^{14}$$）个槽位来记录**卖出该通证的**订单的成交比例。如果订单ID是`N`，那么使用的槽位编号就是`N % 16384`。换言之，如果槽位编号是`m`，该槽位就可以被用来记录具有下列ID的订单：`m`，`m + 16384`，`m + 16384 * 2`，... 以此类推。

每个槽位都记录了当前订单的ID（初始值就是槽位编号），并且后续不接受订单ID比当前订单ID更小的订单。假设槽位1记录的是ID为`32769 = 1 + 16384 * 2`的订单的订单状态，当用户下一个订单ID为`1`或`16385`的订单的时候，下单就会失败。


另外订单ID的最大值是`1048576`，即$$2^{20}$$。到达这个ID上限后，您对应的卖出通证就不能再下卖单了。对于普通用户，这不是大问题；但对于程序化交易，您可能需要注册一个新账号继续交易。

{% hint style='info' %}
路印协议3.5会去除订单ID最大值的限制，但依然保留槽位的设计和数量。
{% endhint %}

值得注意的是，同一个用户在LRC-ETH和LRC-USDT市场的所有买单都是共享上面的16384槽位的。如果您不想在客户端维护市场对间订单ID的分配，您可以注册多个账号，一个账号参与LRC-ETH市场的交易，另一个账号参与LRC-USDT市场的交易。


综合上述信息，我们建议：
1. 使用从0开始逐渐递增的ID作为新订单的ID；
2. 对于特定的卖出通证，下单量如果超过16384，需要您先取消新订单对应的槽位正在记录的老订单，确保槽位释放出来用来记录新订单的成交情况。
3. 如有必要，在客户端维护并计算下一个订单ID（您也可以通过路印API获取下一个订单的ID）。



#### 其它数据项

- `exchangeId`：Loopring.io现在运行的beta1版本的交易所ID，后续路印交易所升级智能合约后，这个`exchangeId`就会更新。beta1对应的`exchangeId`就是2，这是个常量。
- `accountId`：用户的账号ID。
- `allOrNone`：如果是`true`，要求订单要么不成交，要么完全成交。
- `label`: 用于对订单做的特殊标记。交易中不同的参与方可以通过该值来计算利益分配。默认可以赋值为`0`。
- `clientOrderId`: 客户端指定的订单ID。该项数据用来数据统计，不参与签名，独立于路印协议。


- **TODO（马超）**：中继allOrNone已经支持了？





